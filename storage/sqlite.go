package storage

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/ehabterra/workflow"
)

// SQLiteStorage provides a persistent storage implementation using SQLite.
// It is highly configurable to allow for custom table and column names,
// as well as storing arbitrary application-specific data alongside the
// workflow state.
type SQLiteStorage struct {
	db *sql.DB

	// Configuration for the main workflow state table.
	table       string
	idColumn    string
	stateColumn string

	// CustomFields maps a context key to a database column name and its type.
	// Example: {"document_id": "document_id_col TEXT", "approver": "approver_col TEXT"}
	customFields map[string]string
}

// Option is a function that configures a SQLiteStorage.
type Option func(*SQLiteStorage)

// WithTable sets the name of the table used to store workflow state.
// Default: "workflow_states".
func WithTable(name string) Option {
	return func(s *SQLiteStorage) {
		s.table = name
	}
}

// WithIDColumn sets the name of the column used to store the workflow ID.
// Default: "id".
func WithIDColumn(name string) Option {
	return func(s *SQLiteStorage) {
		s.idColumn = name
	}
}

// WithStateColumn sets the name of the column used to store the workflow's current places (state).
// Default: "state".
func WithStateColumn(name string) Option {
	return func(s *SQLiteStorage) {
		s.stateColumn = name
	}
}

// WithCustomFields defines the schema for additional application-specific data to be stored.
// The map key is the key used in the workflow's context map.
// The map value is the full SQL column definition (e.g., "title TEXT", "amount INTEGER NOT NULL").
func WithCustomFields(fields map[string]string) Option {
	return func(s *SQLiteStorage) {
		s.customFields = fields
	}
}

// NewSQLiteStorage creates a new SQLiteStorage with the given options.
func NewSQLiteStorage(db *sql.DB, opts ...Option) (*SQLiteStorage, error) {
	if db == nil {
		return nil, fmt.Errorf("db cannot be nil")
	}

	s := &SQLiteStorage{
		db:           db,
		table:        "workflow_states",
		idColumn:     "id",
		stateColumn:  "state",
		customFields: make(map[string]string),
	}

	for _, opt := range opts {
		opt(s)
	}

	return s, nil
}

// GenerateSchema returns the `CREATE TABLE` SQL statement based on the storage configuration.
// This allows the user to see, modify, or use the schema with a separate migration tool.
func (s *SQLiteStorage) GenerateSchema() string {
	columns := []string{
		fmt.Sprintf("%s TEXT PRIMARY KEY", s.idColumn),
		fmt.Sprintf("%s TEXT NOT NULL", s.stateColumn),
	}

	for _, colDef := range s.customFields {
		columns = append(columns, colDef)
	}

	return fmt.Sprintf("CREATE TABLE IF NOT EXISTS %s (%s);", s.table, strings.Join(columns, ", "))
}

// Initialize executes the schema generated by GenerateSchema.
// It's a convenience helper for development and testing. For production,
// it's recommended to use a proper migration tool.
func Initialize(db *sql.DB, schema string) error {
	_, err := db.Exec(schema)
	return err
}

// SaveState saves the workflow's current places and any configured custom fields from its context.
func (s *SQLiteStorage) SaveState(id string, places []workflow.Place, context map[string]interface{}) error {
	stateJSON, err := json.Marshal(places)
	if err != nil {
		return fmt.Errorf("failed to marshal state: %w", err)
	}

	columns := []string{s.idColumn, s.stateColumn}
	values := []interface{}{id, stateJSON}
	placeholders := []string{"?", "?"}

	for key, colDef := range s.customFields {
		colName := strings.Fields(colDef)[0]
		columns = append(columns, colName)
		placeholders = append(placeholders, "?")

		if val, ok := context[key]; ok {
			values = append(values, val)
		} else {
			values = append(values, nil) // Use NULL if key not in context
		}
	}

	// Using "REPLACE INTO" which is a SQLite-specific convenience.
	// It's equivalent to an INSERT or, if a row with the same primary key exists, a DELETE followed by an INSERT.
	query := fmt.Sprintf("REPLACE INTO %s (%s) VALUES (%s);",
		s.table,
		strings.Join(columns, ", "),
		strings.Join(placeholders, ", "),
	)

	_, err = s.db.Exec(query, values...)
	return err
}

// LoadState loads the workflow's places and all configured custom fields into the context map.
func (s *SQLiteStorage) LoadState(id string) ([]workflow.Place, map[string]interface{}, error) {
	columns := []string{s.stateColumn}
	for _, colDef := range s.customFields {
		colName := strings.Fields(colDef)[0]
		columns = append(columns, colName)
	}

	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?",
		strings.Join(columns, ", "),
		s.table,
		s.idColumn,
	)

	row := s.db.QueryRow(query, id)

	// Prepare to scan into a slice of interface{} pointers
	scanArgs := make([]interface{}, len(columns))
	for i := range columns {
		scanArgs[i] = new(interface{})
	}

	err := row.Scan(scanArgs...)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil, fmt.Errorf("workflow with id %s not found", id)
		}
		return nil, nil, fmt.Errorf("failed to load state: %w", err)
	}

	// Process results
	var stateJSON []byte
	if rawState, ok := (*scanArgs[0].(*interface{})).([]byte); ok {
		stateJSON = rawState
	} else {
		return nil, nil, fmt.Errorf("unexpected type for state column")
	}

	var places []workflow.Place
	if err := json.Unmarshal(stateJSON, &places); err != nil {
		return nil, nil, fmt.Errorf("failed to unmarshal state: %w", err)
	}

	context := make(map[string]interface{})
	customFieldKeys := make([]string, 0, len(s.customFields))
	for k := range s.customFields {
		customFieldKeys = append(customFieldKeys, k)
	}

	for i, key := range customFieldKeys {
		val := *(scanArgs[i+1].(*interface{}))
		// SQLite may return int64 for INTEGER columns, etc.
		// The application layer will need to handle type assertions.
		context[key] = val
	}

	return places, context, nil
}

// DeleteState removes a workflow's state from the database.
func (s *SQLiteStorage) DeleteState(id string) error {
	query := fmt.Sprintf("DELETE FROM %s WHERE %s = ?", s.table, s.idColumn)
	_, err := s.db.Exec(query, id)
	return err
}
